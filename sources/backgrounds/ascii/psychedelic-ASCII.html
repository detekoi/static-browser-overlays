<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Psychedelic ASCII — OBS Browser Source (Efficient)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #000;
      --weight: 700;
      --ls: 0.02em;     /* letter spacing */
      --lh: 0.78;       /* line height (tighter = denser) */
      --blur: 0.0px;    /* subtle bloom on text, try 0.6px */
      --scaleX: 1;      /* GPU upscaling factors (set by JS) */
      --scaleY: 1;
      --drift: 1;       /* 1 = animate gradient drift, 0 = static */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      overflow: hidden;
    }
    .wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    /* We upscale this with a single GPU transform (cheap) */
    .gpu-scale {
      transform: scale(var(--scaleX), var(--scaleY));
      transform-origin: center center;
    }
    pre {
      margin: 0;
      white-space: pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-weight: var(--weight);
      letter-spacing: var(--ls);
      line-height: var(--lh);
      background: conic-gradient(from 0deg,
        #ff004c, #ff8a00, #ffe600, #29ff00, #00ffe1, #008cff, #b300ff, #ff004c);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      filter: drop-shadow(0 0 var(--blur) #fff);
      /* No rotation anymore. Optional slow drift only. */
      animation: drift 9s ease-in-out infinite alternate;
      /* animation-play-state is set via JS, not CSS variable logic */
      user-select: none;
      will-change: contents, background-position; /* hints */
    }
    @keyframes drift { 0% { background-position: 0% 0%; } 100% { background-position: 100% 100%; } }

    @media (prefers-reduced-motion: reduce) {
      pre { animation: none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="gpu-scale">
      <pre id="ascii" aria-hidden="true"></pre>
    </div>
  </div>

  <script>
  (() => {
    // ---------- Params ----------
    const q = new URLSearchParams(location.search);
    const OUT_FS   = +(q.get('fs')     || 12);   // visual font size (px) after scaling
    const RENDER_FS= +(q.get('rfs')    || 8);    // internal render font size (px) — smaller = fewer chars, faster
    const TARGET_FPS = +(q.get('fps')  || 24);   // lower default
    const SPEED      = +(q.get('speed')|| 1.0);
    const DENSITY    = +(q.get('density')|| 1.0);
    const CONTRAST   = +(q.get('contrast')|| 1.0);
    const MODE       = (q.get('mode') || 'low'); // 'low' or 'high'
    const SPARKLE    = +(q.get('sparkle')|| 0);  // 0/1
    const DRIFT      = +(q.get('drift')  || 1);  // 0/1
    const UNIFORM    = +(q.get('uniform')|| 0);  // 0/1 — force uniform scale (may crop)

    // ASCII ramp from "solid" to "air"
    const RAMP = "@#%WM&8B$0X*+=-:.  ";
    const RAMP_LEN = RAMP.length - 1;

    const wrap = document.querySelector('.gpu-scale');
    const el = document.getElementById('ascii');

    // Apply fonts and drift
    document.documentElement.style.setProperty('--drift', DRIFT ? '1' : '0');
    el.style.fontSize = RENDER_FS + 'px';

    // Measuring
    function measureGlyph() {
      const s = document.createElement('span');
      s.textContent = 'M';
      s.style.font = getComputedStyle(el).font;
      s.style.fontSize = getComputedStyle(el).fontSize;
      s.style.lineHeight = getComputedStyle(el).lineHeight;
      s.style.letterSpacing = getComputedStyle(el).letterSpacing;
      s.style.position = 'absolute';
      s.style.visibility = 'hidden';
      document.body.appendChild(s);
      const rect = s.getBoundingClientRect();
      s.remove();
      return {
        cw: Math.max(6, rect.width  || RENDER_FS * 0.6),
        ch: Math.max(6, rect.height || RENDER_FS * 0.9),
      };
    }

    let cols = 0, rows = 0, cw = 0, ch = 0, cx = 0, cy = 0;

    // --------- Precompute coordinate arrays to reduce trig work ---------
    // These speedups help a lot at big grids; we still keep it readable.
    const sinX1 = [], sinX2 = [], sinY1 = [], sinY2 = [];
    function rebuildTables() {
      sinX1.length = sinX2.length = sinY1.length = sinY2.length = 0;
      for (let x = 0; x < cols; x++) {
        sinX1[x] = x * 0.12;
        sinX2[x] = x * 0.07;
      }
      for (let y = 0; y < rows; y++) {
        sinY1[y] = y * 0.09;
        sinY2[y] = y * 0.04;
      }
    }

    function resize() {
      const m = measureGlyph();
      cw = m.cw; ch = m.ch;

      // Render grid at least as large as the unscaled viewport.
      const w = window.innerWidth;
      const h = window.innerHeight;

      const targetScale = Math.max(1, OUT_FS / RENDER_FS);
      const internalW = Math.round(w / targetScale);
      const internalH = Math.round(h / targetScale);

      // Use ceil to avoid underfilling which creates letterboxing.
      cols = Math.max(8, Math.ceil(internalW / cw));
      rows = Math.max(8, Math.ceil(internalH / ch));
      cx = cols * 0.5;  // center x
      cy = rows * 0.5;  // center y

      const contentW = cols * cw;
      const contentH = rows * ch;

      let scaleX = (w / contentW) * targetScale;
      let scaleY = (h / contentH) * targetScale;
      if (UNIFORM) {
        const s = Math.max(scaleX, scaleY); // cover fully, allow crop
        scaleX = s; scaleY = s;
      }
      document.documentElement.style.setProperty('--scaleX', scaleX.toString());
      document.documentElement.style.setProperty('--scaleY', scaleY.toString());

      // Rebuild trig tables when grid changes
      rebuildTables();
    }

    window.addEventListener('resize', resize, { passive: true });
    resize();

    rebuildTables();

    // Rebuild when dimensions change (resize() already rebuilds tables)
    const ro = new ResizeObserver(() => { resize(); });
    ro.observe(el);

    // ---------- Field functions ----------
    function fieldLow(x, y, t, nx, ny, r, a) {
      // Lighter: 2–3 sines
      const k = 0.45 * DENSITY;
      const bands = Math.sin(x * k + Math.sin(y * 0.11 + t * 0.8) * 1.6 + t * 1.1);
      const swirl = Math.sin(8.0 * r - 1.6 * t + a * 4.0);
      let v = (bands * 0.9 + swirl * 0.6) * 0.6;
      v *= CONTRAST;
      return Math.max(-1, Math.min(1, v));
    }

    function fieldHigh(x, y, t, nx, ny, r, a) {
      const k2 = 0.6 * DENSITY, k3 = 0.33 * DENSITY;
      const swirl  = Math.sin( (12.0 * r - 2.4 * t) + a * 5.0 );
      const bands  = Math.sin( (x * k2 + Math.sin(y * 0.12 + t * 0.9) * 2.0) + t * 1.3 );
      const lattice= Math.sin(x * k3 - t) + Math.sin(y * (k3*1.2) + t * 0.7);
      let v = (swirl * 0.55 + bands * 0.8 + lattice * 0.5) / 2.0;
      v *= CONTRAST;
      return Math.max(-1, Math.min(1, v));
    }
    const useHigh = MODE === 'high';

    function sparkle(x, y, t) {
      if (!SPARKLE) return false;
      const s = Math.sin(sinX2[x] + sinY1[y] + t * 1.3) + Math.sin(x * 0.05 - y * 0.04 - t * 1.7);
      return s > 1.55;
    }

    // ---------- Animation loop with stronger FPS cap ----------
    let acc = 0, last = performance.now();
    const frameInterval = 1000 / TARGET_FPS;
    const maxSkip = frameInterval * 3;

    function frame(now) {
      let dt = now - last;
      if (dt > maxSkip) dt = frameInterval; // prevent huge catches
      acc += dt;
      last = now;

      if (acc >= frameInterval) {
        const t = (now / 1000) * SPEED;
        // Build using an array join to avoid giant string concatenation churn
        const lines = new Array(rows);
        for (let y = 0; y < rows; y++) {
          const row = new Array(cols);
          const ny = (y - cy) / Math.max(rows, 1);
          for (let x = 0; x < cols; x++) {
            const nx = (x - cx) / Math.max(cols, 1);
            const r  = Math.hypot(nx, ny);
            const a  = Math.atan2(ny, nx);
            const v  = useHigh ? fieldHigh(x, y, t, nx, ny, r, a)
                               : fieldLow (x, y, t, nx, ny, r, a);
            let ch = RAMP[( (v + 1) * 0.5 * RAMP_LEN ) | 0];
            if (SPARKLE && sparkle(x, y, t)) ch = (x + y) % 2 ? '+' : '*';
            row[x] = ch;
          }
          lines[y] = row.join('');
        }
        el.textContent = lines.join('\n');
        acc = 0;
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
