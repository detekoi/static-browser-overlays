<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Psychedelic ASCII — OBS (Fill, Efficient, No Rotation)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#000;
      --weight:700;
      --ls:0.02em;   /* letter spacing */
      --lh:0.78;     /* line height (tighter = denser) */
      --blur:0px;    /* try 0.6px for a bloom look */
    }
    html, body{
      height:100%;
      margin:0;
      background:var(--bg);
      overflow:hidden;
    }
    .wrap{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      pointer-events:none;
    }
    pre{
      margin:0;
      white-space:pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-weight:var(--weight);
      letter-spacing:var(--ls);
      line-height:var(--lh);
      /* more muted palette with neutrals, grays, purples, pinks, browns, and beige tones; no rotation */
      background: linear-gradient(135deg,
        #2c2c2c, #4b3b47, #7a5c61, #a8896c, #d1c7b7, #a88fa0, #6b5c6e, #2c2c2c);
      background-size:200% 200%;
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      filter: drop-shadow(0 0 var(--blur) #fff);
      user-select:none;
    }
    /* optional gentle drift of the gradient itself */
    @keyframes drift{ 0%{background-position:0% 0%} 100%{background-position:100% 100%} }
    @media (prefers-reduced-motion: reduce){ pre{ animation:none !important; } }
  </style>
</head>
<body>
  <div class="wrap"><pre id="ascii" aria-hidden="true"></pre></div>

  <script>
  (() => {
    // -------- Params --------
    const q = new URLSearchParams(location.search);
    const FONT_SIZE  = +(q.get('fs')      || 16);    // glyph size (px), increased for more negative space
    const TARGET_FPS = +(q.get('fps')     || 24);    // frame cap
    const SPEED      = +(q.get('speed')   || 1.0);
    const DENSITY    = +(q.get('density') || 0.7);   // 0.7..1.3; lowered for less detail and more negative space
    const CONTRAST   = +(q.get('contrast')|| 1.0);   // 0.7..1.4
    const MODE       = (q.get('mode')     || 'low'); // 'low' | 'high'
    const SPARKLE    = +(q.get('sparkle') || 0);     // 0/1
    const DRIFT      = +(q.get('drift')   || 1);     // 0/1 drift of gradient
    const MONO       = +(q.get('mono')    || 0);     // 1 = monochrome glyphs

    const RAMP = "@#%WM&8B$0X*+=-:.  ";
    const RAMP_LEN = RAMP.length - 1;

    const el = document.getElementById('ascii');

    // Visual style toggles (no risk of black screen)
    el.style.fontSize = FONT_SIZE + 'px';
    if (DRIFT) el.style.animation = 'drift 9s ease-in-out infinite alternate';
    if (MONO) {
      // override gradient to plain color if requested
      el.style.background = 'none';
      el.style.webkitBackgroundClip = 'initial';
      el.style.backgroundClip = 'initial';
      el.style.color = '#9aff00';
      el.style.filter = 'drop-shadow(0 0 0)';
    }

    // ----- Measure a glyph to size the grid -----
    function measure() {
      const s = document.createElement('span');
      s.textContent = 'M';
      const cs = getComputedStyle(el);
      s.style.font = cs.font;
      s.style.fontSize = cs.fontSize;
      s.style.lineHeight = cs.lineHeight;
      s.style.letterSpacing = cs.letterSpacing;
      s.style.position = 'absolute';
      s.style.visibility = 'hidden';
      document.body.appendChild(s);
      const r = s.getBoundingClientRect();
      s.remove();
      return {
        cw: Math.max(1, r.width  || FONT_SIZE * 0.6),
        ch: Math.max(1, r.height || FONT_SIZE * 0.9),
      };
    }

    let cols=0, rows=0, cx=0, cy=0, cw=0, ch=0;

    function resize(){
      const m = measure();
      cw = m.cw; ch = m.ch;
      // Use ceil so we always render enough to overfill, then clip — no bars
      cols = Math.max(8, Math.ceil(window.innerWidth  / cw));
      rows = Math.max(8, Math.ceil(window.innerHeight / ch));
      cx = cols * 0.5;
      cy = rows * 0.5;
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // ---------- Field functions ----------
    function fieldLow(x, y, t, nx, ny, r, a) {
      const k = 0.45 * DENSITY;
      const bands = Math.sin(x * k + Math.sin(y * 0.11 + t * 0.8) * 1.6 + t * 1.1);
      const swirl = Math.sin(8.0 * r - 1.6 * t + a * 4.0);
      let v = (bands * 0.9 + swirl * 0.6) * 0.6;
      v *= CONTRAST;
      return Math.max(-1, Math.min(1, v));
    }
    function fieldHigh(x, y, t, nx, ny, r, a) {
      const k2 = 0.6 * DENSITY, k3 = 0.33 * DENSITY;
      const swirl  = Math.sin((12.0 * r - 2.4 * t) + a * 5.0);
      const bands  = Math.sin((x * k2 + Math.sin(y * 0.12 + t * 0.9) * 2.0) + t * 1.3);
      const lattice= Math.sin(x * k3 - t) + Math.sin(y * (k3*1.2) + t * 0.7);
      let v = (swirl * 0.55 + bands * 0.8 + lattice * 0.5) / 2.0;
      v *= CONTRAST;
      return Math.max(-1, Math.min(1, v));
    }
    const useHigh = MODE === 'high';

    function sparkle(x, y, t) {
      if (!SPARKLE) return false;
      const s = Math.sin(x * 0.07 + y * 0.09 + t * 1.3) +
                Math.sin(x * 0.05 - y * 0.04 - t * 1.7);
      return s > 1.55;
    }

    // ---------- Animation loop ----------
    let acc = 0, last = performance.now();
    const frameInterval = 1000 / TARGET_FPS;
    const maxSkip = frameInterval * 3;

    function frame(now){
      let dt = now - last;
      if (dt > maxSkip) dt = frameInterval;
      acc += dt; last = now;

      if (acc >= frameInterval){
        const t = (now / 1000) * SPEED;
        const lines = new Array(rows);
        for (let y = 0; y < rows; y++){
          const row = new Array(cols);
          const ny = (y - cy) / Math.max(rows, 1);
          for (let x = 0; x < cols; x++){
            const nx = (x - cx) / Math.max(cols, 1);
            const r  = Math.hypot(nx, ny);
            const a  = Math.atan2(ny, nx);
            const v  = useHigh ? fieldHigh(x, y, t, nx, ny, r, a)
                               : fieldLow (x, y, t, nx, ny, r, a);
            let ch = RAMP[ ((v + 1) * 0.5 * RAMP_LEN) | 0 ];
            if (sparkle(x, y, t)) ch = ((x + y) & 1) ? '+' : '*';
            row[x] = ch;
          }
          lines[y] = row.join('');
        }
        el.textContent = lines.join('\n');
        acc = 0;
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
